\documentclass[12pt,twocolumn]{report}
\usepackage[greek,english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{latexsym}

\author{\el Ευστράτιος Μυλωνάς 534 \\ \el Ιωάννης Αντωνίου 491}

\title{\el Συστήματα Παράλληλης και Κατανεμημένης Επεξεργασίας \\ \setlength{\parskip}{80pt plus 1pt minus 1pt} \en Parallelizing Hierarchical Search for Video Motion Estimation using OpenMP and Open MPI}

\newcommand{\el}{\selectlanguage{greek}}
\newcommand{\en}{\selectlanguage{english}}


\begin{document}
\maketitle

\textbf {\el Εισαγωγή \\ \setlength{\parskip}{80pt plus 1pt minus 1pt}}

\el 
Η εργασία μας ξεκίνησε αρχικά με την μελέτη του προγράμματος και την κατανόηση των λειτουργιών του κάθε αρχείου ξεχωριστά και τον τρόπο με τον οποίο αυτά συνδέονται μεταξύ τους για την ορθή λειτουργία του προγράμματος. Αντιμετωπίσαμε πολλές δυσκολίες στο πως λειτουργεί η κάθε συνάρτηση και κατά πόσο χρησιμοποιείτε στο πρόγραμμα μας. Το σειριακό πρόγραμμα είχε χρόνο εκτέλεσης στο μηχάνημα \en mach-one \el (όπου εκεί έγιναν και όλες οι παραλληλοποιήσεις για να έχουμε κοινό σημείο αναφοράς) περίπου 6.95 δευτερόλεπτα. Το \en SNR \el του σειριακού είναι 40.301233. \\ \el

Σκοπός της εργασίας μας ήταν να παραλληλοποιήσουμε τον αρχικό σειριακό κώδικα με 4 διαφορετικούς τρόπου παραλληλοποίησης κατά \en OpenMP \el και άλλους 4 κατά \en OpenMPI. \el Επιλέξαμε να υλοποιήσουμε 4 κατά \en OpenMP, \el 2 κατά \en OpenMPI \el και 2 με συνδυασμό των 2. \\ \el

Χρησιμοποιήσαμε διάφορες τεχνικές παραλληλοποίησης ώστε να φτάσουμε στο επιθυμητό αποτέλεσμα, με όσο το δυνατόν λιγότερες αλλαγές στο αρχικό σειριακό πρόγραμμα. Στόχος μας ήταν να μειώσουμε τον χρόνο εκτέλεσης, σε σχέση με το αρχικό πρόγραμμα, κρατώντας το αποτέλεσμα \en SNR \el σταθερό. \\ \el
 
\textbf {\el Εύρεση Κρίσιμου Σημείου με \en gprof \\ \setlength{\parskip}{80pt plus 1pt minus 1pt}}

\el
Αρχικά, η πρώτη μας κίνηση ήταν να βρούμε ποιο σημείο κώδικα επιβαρύνει το πρόγραμμα, ώστε να στοχεύσουμε στην βελτιστοποίηση/παραλληλοποίησή του. Το εργαλείο που μας βοήθησε σε αυτό ήταν το \en gprof, \el που μας έδειξε ότι η συνάρτηση \en hs\_motion\_estimation2 \el καταναλώνει περισσότερο χρόνο, με βάση τον συνολικό χρόνο εκτέλεσης, και εκτελείτε περισσότερες φορές, από κάθε άλλη συνάρτηση του προγράμματος, με μεγάλη διαφορά. \\ \el

Έτσι λοιπόν επικεντρωθήκαμε στο εσωτερικό της συνάρτησης, που βρίσκεται στο αρχείο \en hs.c, \el καθώς και στα σημεία που γίνεται η κλήση της συνάρτησης, δηλαδή στην \en main. \el Αναλύοντας την συνάρτηση \en  hs\_motion\_estimation2, \el παρατηρήσαμε ότι αποτελείται από 3 βασικά κομμάτια κώδικα, που το καθένα περιλαμβάνει πολλαπλές εμφωλευμένες επαναλήψεις \en for, \el κάτι που επιβαρύνει την λειτουργία και τον χρόνο εκτέλεσης του προγράμματος. Έτσι προχωράμε στις παρακάτω παραλληλοποιήσεις. \\
\clearpage

\textbf {\el Παραλληλοποιήσεις κατά \en OpenMP}
\\
\el

\underline{\el Πρώτη παραλληλοποίηση \\}
\\
\el


Η πρώτη παραλληλοποίηση έγινε με τη χρήση \en omp parallel sections \el, προκειμένου να εκτελέσουμε τα 3 βασικά κομμάτια επαναλήψεων \en for \el ταυτόχρονα. Έτσι λοιπόν τοποθετήσαμε στην αρχή της συνάρτησης, κάτω από τις κλήσεις των συναρτήσεων \en subsampling2  \el και \en sumsampling4,\el την εντολή  \en \# pragma omp parallel sections num\_threads(3) , \el ώστε να δημιουργήσουμε 3 \en omp threads, \el που το καθένα εκτελεί τα 3 \en sections \el που ακολουθούν.  Επίσης τοποθετήσαμε την εντολή \en \#pragma omp section, \el που η καθεμιά περιλαμβάνει τα βασικά κομμάτια επαναλήψεων \en for. \el
\\

Παρατηρήσεις:
Ο χρόνος εκτέλεσης έχει μειωθεί αισθητά και ο νέος χρόνος εκτέλεσης είναι περίπου 1.88 δευτερόλεπτα. Το \en SNR \el όμως έχει κάποια απόκλιση, περίπου κατά -0.7.
Έτσι το \en speedup \el είναι: \\
\en speedup \el = χρόνος εκτέλεσης σειριακού / χρόνος εκτέλεσης παραλληλοποιημένου \\
\en speedup \el = 6.95 / 1.88 = 3.6968
\\ \el

\underline{\elΔεύτερη παραλληλοποίηση\\}
\\
\el


 Η δεύτερη παραλληλοποίηση έγινε με τη χρήση μιας επιπλέον επανάληψης \en for,\el τριών βημάτων, που περιλαμβάνει 3 ελέγχους \en if, \el ώστε για κάθε τιμή του μετρητή, να εκτελείται ένα από τα βασικά κομμάτια επαναλήψεων \en for \el ενώ πάνω από αυτή τοποθετήσαμε \en \#pragma omp parallel for, \el προκειμένου να εκτελέσουμε τα 3 βασικά κομμάτια επαναλήψεων \en for \el ταυτόχρονα. 
\\ \el

 Παρατηρήσεις:
Ο χρόνος εκτέλεσης έχει μειωθεί αισθητά και ο νέος χρόνος εκτέλεσης είναι περίπου 1.89 δευτερόλεπτα. Το \en SNR \el όμως έχει κάποια απόκλιση, περίπου κατά -0.1.
Έτσι το \en speedup \el είναι:\\
\en speedup \el= χρόνος εκτέλεσης σειριακού / χρόνος εκτέλεσης παραλληλοποιημένου\\
\en speedup \el= 6.95 / 1.89 = 3.6960
\\ 


\underline{\elΤρίτη παραλληλοποίηση\\}
\el
\\

 Η τρίτη παραλληλοποίηση έγινε στο αρχείο \en main.c \el με την τοποθέτηση της εντολής \en \#pragma omp parallel for private (i) schedule (dynamic, 3)\el στο σημείο που γίνεται η επανάληψη της κλήσης της συνάρτησης \en hs\_motion\_estimation2. \el  Με αυτόν τον τρόπο δημιουργούνται νήματα τα οποία εκτελούν την διαδικασία της επανάληψης με παράλληλο τρόπο.

\el

Παρατηρήσεις:
Ο χρόνος εκτέλεσης έχει μειωθεί αισθητά και ο νέος χρόνος εκτέλεσης είναι περίπου 5.05 δευτερόλεπτα. Το \en SNR \el όμως έχει κάποια απόκλιση, περίπου κατά +0.5.
Έτσι το \en speedup \el είναι:\\
\en speedup\el = χρόνος εκτέλεσης σειριακού / χρόνος εκτέλεσης παραλληλοποιημένου\\
\en speedup \el = 6.95 / 5.05 = 1.37623
\\

\underline{\elΤέταρτη παραλληλοποίηση\\}
\el
\\

Η τέταρτη παραλληλοποίηση έγινε στο αρχείο\en hs.c \el στην συνάρτηση \en hs\_motion\_estimation2 \el  με την τοποθέτηση της εντολής \en \#pragma omp parallel for collapse(2) \el στις τρείς βασικές επαναλήψεις \en for \el που παραλληλοποιεί τις επαναλήψεις \en for \el και με το \en collapse(2) \el ενώνει τις 2 \en for \el.
\\

Παρατηρήσεις:
Ο χρόνος εκτέλεσης έχει μειωθεί αισθητά και ο νέος χρόνος εκτέλεσης είναι περίπου 2.96 δευτερόλεπτα. Το \en SNR \el όμως έχει κάποια απόκλιση, περίπου κατά +0.6.
Έτσι το \en speedup \el είναι:\\
en\ speedup \el = χρόνος εκτέλεσης σειριακού / χρόνος εκτέλεσης παραλληλοποιημένου\\
\en speedup \el = 6.95 / 2.96 = 2.3479
\\


\textbf {\el Παραλληλοποιήσεις κατά \en OpenMPI}
\\ \el

\underline{\el Πρώτη παραλληλοποίηση \\}
\el
\\

Η πρώτη παραλληλοποίηση έγινε με τη χρήση \en 3 MPI Ranks \el, στην συνάρτηση \en  hs\_motion\_estimation2.\el . Έχουμε τοποθετήσει συνθήκες \en if \el με τέτοιο τρόπο ώστε το κάθε \en Rank \el να περιλαμβάνει και από ένα βασικό κομμάτι επανάληψης \en for \el. Οι κλήσεις των \en MPI\_Init \el και \en MPI\_Finalize \el για την αρχικοποίηση και τον τερματισμό των \en ranks, \el καθώς και ο καθορισμός του αριθμού του κάθε \en rank \el και του συνολικού αριθμού των \en processors \el γίνεται στη \en main \el. Επίσης έχουν τοποθετηθεί κατάλληλοι έλεγχοι για περιπτώσεις όπως πχ. εκτέλεση του προγράμματος με αριθμό επεξεργαστών μικρότερο του 3.
\\

Παρατηρήσεις:
Ο χρόνος εκτέλεσης έχει μειωθεί αισθητά και ο νέος χρόνος εκτέλεσης είναι περίπου 2.25 δευτερόλεπτα. Το \en SNR \el όμως έχει κάποια απόκλιση, περίπου κατά +0.7.
Έτσι το \en speedup \el είναι:\\
\en speedup \el = χρόνος εκτέλεσης σειριακού / χρόνος εκτέλεσης παραλληλοποιημένου\\
\en speedup \el = 6.95 / 2.25 = 3.08
\\


\underline{\el Δεύτερη παραλληλοποίηση \\}
\el
\\

Η δεύτερη παραλληλοποίηση έγινε με τη χρήση \en 2 MPI Ranks \el, στην συνάρτηση \en  main.\el . Έχουμε τοποθετήσει συνθήκες \en if \el με τέτοιο τρόπο ώστε το κάθε \en Rank \el να αναλαμβάνει τις μισές επαναλήψεις από τις συνολικές που γίνονται, στο σημείο που γίνεται και η κλήση της \en  hs\_motion\_estimation2. \el Ο διαμοιρασμός γίνεται με ανάλογα με το αν η τιμή του \en i \el είναι άρτια ή περιττή. Όπως και πριν τοποθετήθηκαν οι αντίστοιχες συναρτήσεις για την αρχικοποίηση και τον τερματισμό των \en ranks\el, την εύρεση των \en size \el και \en rank \el καθώς και σημεία ελέγχου σωστής κλήσης.
\\

Παρατηρήσεις:
Ο χρόνος εκτέλεσης έχει μειωθεί αισθητά και ο νέος χρόνος εκτέλεσης είναι περίπου 1,75 δευτερόλεπτα. Το \en SNR \el όμως έχει κάποια απόκλιση, περίπου κατά +0.7.
Έτσι το \en speedup \el είναι:\\
\en speedup \el = χρόνος εκτέλεσης σειριακού / χρόνος εκτέλεσης παραλληλοποιημένου\\
\en speedup \el = 6.95 / 1.75 = 3.97
\\


\textbf {\el Παραλληλοποιήσεις κατά \en OpenMP + OpenMPI}
\\ \el

\underline{\el Πρώτη παραλληλοποίηση \\}
\el
\\

Η πρώτη μικτή παραλληλοποίηση έγινε με τη χρήση \en 2 MPI Ranks \el, στην συνάρτηση \en main.\el σε συνδυασμό με την χρήση της μεθόδου με την επιπλέον \en for \el που χρησιμοποιήθηκε στη δεύτερη παραλληλοποίηση με \en OpenMP \el. Στην \en main \el, έχουμε τον διαμοιρασμό των επαναλήψεων της \en for \el που καλεί την συνάρτηση \en  hs\_motion\_estimation2\el, όπως είχε γίνει στην δεύτερη παραλληλοποίηση κατά \en OpenMPI \el.
\\

Παρατηρήσεις:
Ο χρόνος εκτέλεσης έχει μειωθεί αισθητά και ο νέος χρόνος εκτέλεσης είναι περίπου 1,89 δευτερόλεπτα. Το \en SNR \el όμως έχει κάποια απόκλιση, περίπου κατά +0.1.
Έτσι το \en speedup \el είναι:\\
\en speedup \el = χρόνος εκτέλεσης σειριακού / χρόνος εκτέλεσης παραλληλοποιημένου\\
\en speedup \el = 6.95 / 1.89 = 3,68
\\


\underline{\el Δεύτερη παραλληλοποίηση \\}
\el
\\

Η δεύτερη παραλληλοποίηση έγινε με τη χρήση \en 3 MPI Ranks \el, στην συνάρτηση \en  hs\_motion\_estimation2 \el σε συνδυασμό με την χρήση της εντολής \en \#pragma omp parallel for private (i) schedule (dynamic, 3) \el στο σημείο που γίνεται η επανάληψη της κλήσης της συνάρτησης \en hs\_motion\_estimation2 \el. Έχουμε τοποθετήσει συνθήκες \en if \el με τέτοιο τρόπο ώστε το κάθε \en Rank \el να περιλαμβάνει και από ένα βασικό κομμάτι επανάληψης \en for \el, όπως και στην πρώτη παραλληλοποίηση κατά \en OpenMPI\el.
\\

Παρατηρήσεις:
Ο χρόνος εκτέλεσης έχει μειωθεί αισθητά και ο νέος χρόνος εκτέλεσης είναι περίπου 2.88 δευτερόλεπτα. Το \en SNR \el όμως έχει κάποια απόκλιση, περίπου κατά +0.5.
Έτσι το \en speedup \el είναι:\\
\en speedup \el = χρόνος εκτέλεσης σειριακού / χρόνος εκτέλεσης παραλληλοποιημένου\\
\en speedup \el = 6.95 / 2.88 = 2.413
\\
\el

\textbf {\\ \el Πρόσθετες αλλαγές στις παραλληλοποιήσεις}
\\ \el

Σε κάθε παραλληλοποίηση έγιναν οι κατάλληλες αλλαγές και προσθήκες στα \en Makefile \el, προκειμένου με τις εντολές \en make, make clean \el και \en make execute \el να εκτελούνται κανονικά όπως θα έπρεπε. Προσθέσαμε πρόσθετες ετικέτες /\en flags \el για την σωστή μεταγλώττιση και σύνδεση του προγράμματος, καθώς και αλλαγή μεταγλωττιστή, όπου αυτό ήταν απαραίτητο πχ. αλλαγή του \en gcc \el σε \en mpicc \el. 


\textbf {\\ \el Σχολιασμός Αποτελεσμάτων}
\\ \el

Αν και καταφέραμε να μειώσουμε αρκετά το χρόνο εκτέλεσης των προγραμμάτων, χρησιμοποιώντας παραλληλοποιήσεις \en OpenMP, OpenMPI \el καθώς και συνδυαστικές μεθόδους των δύο, δυσκολευτήκαμε στο να κρατήσουμε την τιμή του αποτελέσματος \en SNR \el σταθερή. Μπορέσαμε όμως και στις οκτώ παραλληλοποιήσεις, που αναλύθηκαν παραπάνω, να το διατηρήσουμε την απόκληση κατά 0.8 μονάδες, σε απόλυτη τιμή, ώστε να μην ξεπερνάει το αρχικό \en SNR \el πάνω από μια μονάδα.\\ \el

Θεωρούμε ότι οι παραλληλοποιήσιες πραγματοποιήθηκαν σε ικανοποιητικό επίπεδο, με βάση τον περιορισμένο χρόνο που είχαμε και το φόρτο εργασίας. Καλύψαμε κατά μεγάλο ποσοστό τους βασικούς σκοπούς της εργασίας που μας ανατέθηκε. \\ \el

Ακόμα όλες οι παραλληλοποιήσεις μεταγλωττίζονται επιτυχώς χωρίς κάποιο \en warning/error \el κατά την μεταγλώττιση.

\clearpage
\textbf {\\ \el Δυσκολίες που αντιμετωπίσαμε}
\\ 
\el

Στην πορεία υλοποίησης της εργασίας αντιμετωπίσαμε διάφορα προβλήματα, κυρίως με το συγχρονισμό των νημάτων/\en ranks \el, κάτι που το παρατηρούσαμε είτε από την υπέρμετρη απόκληση του αποτελέσματος, είτε από τον μεγάλο χρόνο εκτέλεσης του προγράμματος. Επίσης είχαμε δυσκολία ώστε να κατανοήσουμε τον κώδικα και πως αυτός λειτουργεί.\\

Ο χρόνος υλοποίησης της εργασίας αυτής ήταν μια εβδομάδα.\\
\textbf {\\ \el Επίλογος}
\\ 
\el

Μετά από την ενασχόληση με το αντικείμενο της εργασίας μας, μπορούμε να εξάγουμε το συμπέρασμα ότι η παραλληλοποίηση ενός σύνθετου προγράμματος είναι πολύ σημαντική, δεδομένου ότι επιταχύνει πολύ τον χρόνο εκτέλεσης του προγράμματος και το κάνει να χρησιμοποιεί πιο αποδοτικά τους διαθέσιμους πόρους του συστήματος. Οι τρόποι με τους οποίους μπορεί να χρησιμοποιηθεί η παραλληλοποίηση είναι πάρα πολλοί, καθώς και οι διαφορετικοί διαθέσιμοι μέθοδοι και εργαλεία που υπάρχουν. Μάθαμε να χειριζόμαστε καλύτερα τις μεθόδους παραλληλοποίησης και να τις εφαρμόζουμε στα σωστά σημεία ενός κώδικα.\\

 Μαζί με τους κώδικες (χωρισμένους σε φακέλους), παραθέτοντας και \en print screens \el με ενδεικτικές εκτελέσεις και αποτελέσματα για καθεμιά.


\end{document}